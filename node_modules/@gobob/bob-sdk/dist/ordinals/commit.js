"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCommitTxData = exports.createInscriptionScript = exports.chunkContent = exports.createInscription = exports.createTextInscription = exports.MAX_CHUNK_SIZE = void 0;
const bitcoin = __importStar(require("bitcoinjs-lib"));
const encoder = new TextEncoder();
exports.MAX_CHUNK_SIZE = 520;
function createTextInscription(text) {
    return createInscription("text/plain;charset=utf-8", Buffer.from(encoder.encode(text)));
}
exports.createTextInscription = createTextInscription;
function createInscription(contentType, content) {
    return {
        contentType: Buffer.from(encoder.encode(contentType)),
        content
    };
}
exports.createInscription = createInscription;
function chunkContent(data) {
    const body = [];
    let start = 0;
    while (start < data.length) {
        body.push(data.subarray(start, start + exports.MAX_CHUNK_SIZE));
        start += exports.MAX_CHUNK_SIZE;
    }
    return body;
}
exports.chunkContent = chunkContent;
function createInscriptionScript(xOnlyPublicKey, inscription) {
    const protocolId = Buffer.from(encoder.encode("ord"));
    return [
        xOnlyPublicKey,
        bitcoin.opcodes.OP_CHECKSIG,
        bitcoin.opcodes.OP_0,
        bitcoin.opcodes.OP_IF,
        protocolId,
        1,
        1,
        inscription.contentType,
        bitcoin.opcodes.OP_0,
        ...chunkContent(inscription.content),
        bitcoin.opcodes.OP_ENDIF,
    ];
}
exports.createInscriptionScript = createInscriptionScript;
function toXOnly(pubkey) {
    return pubkey.subarray(1, 33);
}
function createCommitTxData(network, publicKey, inscription) {
    var _a;
    const xOnlyPublicKey = toXOnly(publicKey);
    const script = createInscriptionScript(xOnlyPublicKey, inscription);
    const outputScript = bitcoin.script.compile(script);
    const scriptTree = {
        output: outputScript,
        redeemVersion: 192,
    };
    const scriptTaproot = bitcoin.payments.p2tr({
        internalPubkey: xOnlyPublicKey,
        scriptTree,
        redeem: scriptTree,
        network,
    });
    const cblock = (_a = scriptTaproot.witness) === null || _a === void 0 ? void 0 : _a[scriptTaproot.witness.length - 1];
    const tapLeafScript = {
        leafVersion: scriptTaproot.redeemVersion,
        script: outputScript,
        controlBlock: cblock,
    };
    return {
        scriptTaproot,
        tapLeafScript,
    };
}
exports.createCommitTxData = createCommitTxData;
//# sourceMappingURL=commit.js.map