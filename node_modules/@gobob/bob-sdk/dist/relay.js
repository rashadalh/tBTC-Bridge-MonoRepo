"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBitcoinHeaders = exports.getBitcoinTxProof = exports.getBitcoinTxInfo = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const utils_1 = require("./utils");
async function getBitcoinTxInfo(electrsClient, txId, forWitness) {
    const txHex = await electrsClient.getTransactionHex(txId);
    const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);
    const versionBuffer = Buffer.allocUnsafe(4);
    versionBuffer.writeInt32LE(tx.version);
    const locktimeBuffer = Buffer.allocUnsafe(4);
    locktimeBuffer.writeInt32LE(tx.locktime);
    return {
        version: versionBuffer.toString("hex"),
        inputVector: (0, utils_1.encodeRawInput)(tx).toString("hex"),
        outputVector: (0, utils_1.encodeRawOutput)(tx).toString("hex"),
        locktime: locktimeBuffer.toString("hex"),
        witnessVector: forWitness ? (0, utils_1.encodeRawWitness)(tx).toString("hex") : undefined,
        witnessVector: forWitness ? (0, utils_1.encodeRawWitness)(tx).toString("hex") : undefined,
    };
}
exports.getBitcoinTxInfo = getBitcoinTxInfo;
async function getBitcoinTxProof(electrsClient, txId, txProofDifficultyFactor) {
    const merkleProof = await electrsClient.getMerkleProof(txId);
    const bitcoinHeaders = await getBitcoinHeaders(electrsClient, merkleProof.blockHeight, txProofDifficultyFactor);
    return {
        merkleProof: merkleProof.merkle,
        txIndexInBlock: merkleProof.pos,
        bitcoinHeaders: bitcoinHeaders,
    };
}
exports.getBitcoinTxProof = getBitcoinTxProof;
async function getBitcoinHeaders(electrsClient, startHeight, numBlocks) {
    const range = (start, end) => Array.from({ length: end - start }, (_element, index) => index + start);
    const blockHeights = range(startHeight, startHeight + numBlocks);
    const bitcoinHeaders = await Promise.all(blockHeights.map(async (height) => {
        const hash = await electrsClient.getBlockHash(height);
        return electrsClient.getBlockHeader(hash);
    }));
    return bitcoinHeaders.join('');
}
exports.getBitcoinHeaders = getBitcoinHeaders;
//# sourceMappingURL=relay.js.map