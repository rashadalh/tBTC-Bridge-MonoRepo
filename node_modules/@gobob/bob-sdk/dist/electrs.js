"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultElectrsClient = exports.REGTEST_ESPLORA_BASE_PATH = exports.TESTNET_ESPLORA_BASE_PATH = exports.MAINNET_ESPLORA_BASE_PATH = void 0;
exports.MAINNET_ESPLORA_BASE_PATH = "https://btc-mainnet.gobob.xyz";
exports.TESTNET_ESPLORA_BASE_PATH = "https://btc-testnet.gobob.xyz";
exports.REGTEST_ESPLORA_BASE_PATH = "http://localhost:3003";
function encodeElectrsMerkleProof(merkle) {
    return merkle.map(item => Buffer.from(item, "hex").reverse().toString("hex")).join('');
}
class DefaultElectrsClient {
    constructor(networkOrUrl = "mainnet") {
        switch (networkOrUrl) {
            case "mainnet":
                this.basePath = exports.MAINNET_ESPLORA_BASE_PATH;
                break;
            case "testnet":
                this.basePath = exports.TESTNET_ESPLORA_BASE_PATH;
                break;
            case "regtest":
                this.basePath = exports.REGTEST_ESPLORA_BASE_PATH;
                break;
            default:
                this.basePath = networkOrUrl;
        }
    }
    async getBlockHash(height) {
        return this.getText(`${this.basePath}/block-height/${height}`);
    }
    async getBlockHeader(hash) {
        return this.getText(`${this.basePath}/block/${hash}/header`);
    }
    async getBlockHeaderAt(height) {
        const blockHash = await this.getBlockHash(height);
        return await this.getBlockHeader(blockHash);
    }
    async getTransactionHex(txId) {
        return this.getText(`${this.basePath}/tx/${txId}/hex`);
    }
    async getMerkleProof(txId) {
        const response = await this.getJson(`${this.basePath}/tx/${txId}/merkle-proof`);
        return {
            blockHeight: response.block_height,
            merkle: encodeElectrsMerkleProof(response.merkle),
            pos: response.pos,
        };
    }
    async getFeeEstimate(confirmationTarget) {
        const response = await this.getJson(`${this.basePath}/fee-estimates`);
        return response[confirmationTarget];
    }
    async getAddressUtxos(address, confirmed) {
        const response = await this.getJson(`${this.basePath}/address/${address}/utxo`);
        return response
            .filter(utxo => (typeof confirmed !== "undefined") ? confirmed === utxo.status.confirmed : true)
            .map(utxo => {
            return {
                txid: utxo.txid,
                vout: utxo.vout,
                value: utxo.value,
                confirmed: utxo.status.confirmed,
                height: utxo.status.block_height
            };
        });
    }
    async broadcastTx(txHex) {
        const res = await fetch(`${this.basePath}/tx`, {
            method: 'POST',
            body: txHex
        });
        return await res.text();
    }
    async getJson(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(response.statusText);
        }
        return await response.json();
    }
    async getText(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(response.statusText);
        }
        return await response.text();
    }
}
exports.DefaultElectrsClient = DefaultElectrsClient;
//# sourceMappingURL=electrs.js.map