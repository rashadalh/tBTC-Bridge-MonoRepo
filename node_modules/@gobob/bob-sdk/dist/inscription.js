"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInscriptionFromId = exports.getTxInscriptions = exports.parseInscriptions = exports.getContentEncoding = exports.getContentType = exports.PROTOCOL_ID = void 0;
const bitcoin = __importStar(require("bitcoinjs-lib"));
const ordinal_api_1 = require("./ordinal-api");
const TAPROOT_ANNEX_PREFIX = 0x50;
exports.PROTOCOL_ID = Buffer.from("6f7264", "hex");
const CONTENT_TYPE_TAG = bitcoin.opcodes.OP_1;
const CONTENT_ENCODING_TAG = bitcoin.opcodes.OP_9;
function getTapscript(witness) {
    const len = witness.length;
    const last = witness[len - 1];
    if (typeof last === 'undefined') {
        return null;
    }
    let scriptPosFromLast = 2;
    if (len >= 2 && last[0] == TAPROOT_ANNEX_PREFIX) {
        scriptPosFromLast = 3;
    }
    if (typeof witness[len - scriptPosFromLast] === 'undefined') {
        return null;
    }
    return bitcoin.script.decompile(witness[len - scriptPosFromLast]);
}
;
function getContentType(inscription) {
    const data = inscription.tags[CONTENT_TYPE_TAG];
    if (Buffer.isBuffer(data)) {
        return data.toString("utf-8");
    }
    return null;
}
exports.getContentType = getContentType;
function getContentEncoding(inscription) {
    const data = inscription.tags[CONTENT_ENCODING_TAG];
    if (Buffer.isBuffer(data)) {
        return data.toString("utf-8");
    }
    return null;
}
exports.getContentEncoding = getContentEncoding;
function parseInscriptions(tx) {
    let inscriptions = [];
    for (const txInput of tx.ins) {
        const tapscript = getTapscript(txInput.witness);
        if (tapscript == null) {
            continue;
        }
        const chunks = tapscript.values();
        for (let chunk = chunks.next(); !chunk.done; chunk = chunks.next()) {
            if (chunk.value != bitcoin.opcodes.OP_FALSE) {
                continue;
            }
            if (chunks.next().value != bitcoin.opcodes.OP_IF) {
                continue;
            }
            const data = chunks.next().value;
            if (!Buffer.isBuffer(data) && !data.equals(exports.PROTOCOL_ID)) {
                continue;
            }
            let tags = {};
            let body = [];
            let isBody = false;
            for (let chunk = chunks.next(); !chunk.done; chunk = chunks.next()) {
                if (chunk.value == bitcoin.opcodes.OP_ENDIF) {
                    inscriptions.push({ tags, body });
                    break;
                }
                else if (chunk.value == bitcoin.opcodes.OP_0) {
                    isBody = true;
                    continue;
                }
                if (!isBody) {
                    const data = chunks.next().value;
                    if (typeof chunk.value == 'number' && Buffer.isBuffer(data)) {
                        tags[chunk.value] = data;
                    }
                }
                else if (Buffer.isBuffer(chunk.value)) {
                    body.push(chunk.value);
                }
            }
        }
    }
    return inscriptions;
}
exports.parseInscriptions = parseInscriptions;
async function getTxInscriptions(electrsClient, txid) {
    const txHex = await electrsClient.getTransactionHex(txid);
    const tx = bitcoin.Transaction.fromHex(txHex);
    return parseInscriptions(tx);
}
exports.getTxInscriptions = getTxInscriptions;
async function getInscriptionFromId(electrsClient, inscriptionId) {
    const { txid, index } = ordinal_api_1.InscriptionId.fromString(inscriptionId);
    const inscriptions = await getTxInscriptions(electrsClient, txid);
    return inscriptions[index];
}
exports.getInscriptionFromId = getInscriptionFromId;
//# sourceMappingURL=inscription.js.map