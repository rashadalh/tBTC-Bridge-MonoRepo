"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMerkleProof = exports.encodeRawWitness = exports.encodeRawOutput = exports.encodeRawInput = void 0;
const bufferutils_1 = require("bitcoinjs-lib/src/bufferutils");
const crypto_1 = require("bitcoinjs-lib/src/crypto");
function varSliceSize(someScript) {
    const length = someScript.length;
    return bufferutils_1.varuint.encodingLength(length) + length;
}
function encodeRawInput(tx) {
    const inputSize = bufferutils_1.varuint.encodingLength(tx.ins.length) + tx.ins.reduce((sum, input) => {
        return sum + 40 + varSliceSize(input.script);
    }, 0);
    const inputBuffer = Buffer.allocUnsafe(inputSize);
    const inputBufferWriter = new bufferutils_1.BufferWriter(inputBuffer, 0);
    inputBufferWriter.writeVarInt(tx.ins.length);
    tx.ins.forEach(txIn => {
        inputBufferWriter.writeSlice(txIn.hash);
        inputBufferWriter.writeUInt32(txIn.index);
        inputBufferWriter.writeVarSlice(txIn.script);
        inputBufferWriter.writeUInt32(txIn.sequence);
    });
    return inputBuffer;
}
exports.encodeRawInput = encodeRawInput;
function isOutput(out) {
    return out.value !== undefined;
}
function encodeRawOutput(tx) {
    const outputSize = bufferutils_1.varuint.encodingLength(tx.outs.length) + tx.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
    }, 0);
    const outputBuffer = Buffer.allocUnsafe(outputSize);
    const outputBufferWriter = new bufferutils_1.BufferWriter(outputBuffer, 0);
    outputBufferWriter.writeVarInt(tx.outs.length);
    tx.outs.forEach(txOut => {
        if (isOutput(txOut)) {
            outputBufferWriter.writeUInt64(txOut.value);
        }
        else {
            outputBufferWriter.writeSlice(txOut.valueBuffer);
        }
        outputBufferWriter.writeVarSlice(txOut.script);
    });
    return outputBuffer;
}
exports.encodeRawOutput = encodeRawOutput;
function vectorSize(someVector) {
    const length = someVector.length;
    return (bufferutils_1.varuint.encodingLength(length) +
        someVector.reduce((sum, witness) => {
            return sum + varSliceSize(witness);
        }, 0));
}
function encodeRawWitness(tx) {
    const witnessSize = tx.ins.reduce((sum, input) => {
        return sum + vectorSize(input.witness);
    }, 0);
    const witnessBuffer = Buffer.allocUnsafe(witnessSize);
    const witnessBufferWriter = new bufferutils_1.BufferWriter(witnessBuffer, 0);
    tx.ins.forEach(input => {
        witnessBufferWriter.writeVector(input.witness);
    });
    return witnessBuffer;
}
exports.encodeRawWitness = encodeRawWitness;
function chunkArray(array, chunkSize) {
    const chunkedArray = [];
    let index = 0;
    while (index < array.length) {
        chunkedArray.push(array.slice(index, index + chunkSize));
        index += chunkSize;
    }
    return chunkedArray;
}
function createMerkleBranchAndRoot(hashes, index) {
    let merkle = [];
    while (hashes.length > 1) {
        if (hashes.length % 2 != 0) {
            let last = hashes[hashes.length - 1];
            hashes.push(last);
        }
        if (index % 2 == 0) {
            index++;
        }
        else {
            index--;
        }
        merkle.push(hashes[index]);
        index = Math.floor(index / 2);
        hashes = chunkArray(hashes, 2).map(pair => (0, crypto_1.hash256)(Buffer.concat([pair[0], pair[1]])));
    }
    return {
        merkle,
        root: hashes[0],
    };
}
function getMerkleProof(block, txHash, forWitness) {
    const txIds = block.transactions.map(tx => tx.getHash(forWitness));
    const pos = txIds.map(value => value.toString("hex")).indexOf(txHash);
    const merkleAndRoot = createMerkleBranchAndRoot(txIds, pos);
    return {
        pos: pos,
        proof: merkleAndRoot.merkle.map(value => value.toString("hex")).join(''),
        root: merkleAndRoot.root.toString("hex"),
    };
}
exports.getMerkleProof = getMerkleProof;
//# sourceMappingURL=utils.js.map